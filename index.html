<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Boss Respawn Timers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: #05060a;
      color: #f5f5f5;
      padding: 20px;
      min-height: 100vh;
    }

    .page {
      max-width: 1100px;
      margin: 0 auto;
    }

    h1 {
      font-size: 26px;
      font-weight: 700;
      margin-bottom: 16px;
    }

    .subtitle {
      font-size: 14px;
      margin-bottom: 24px;
      opacity: 0.8;
    }

    .boss-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 16px;
    }

    .boss-card {
      background: #10121a;
      border-radius: 12px;
      padding: 14px 16px;
      border: 1px solid #232738;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .boss-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .boss-name {
      font-size: 16px;
      font-weight: 600;
    }

    .boss-type {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #444a63;
    }

    .boss-type.dynamic {
      border-color: #3b82f6;
    }

    .boss-type.fixed {
      border-color: #f97316;
    }

    .label {
      font-size: 11px;
      text-transform: uppercase;
      opacity: 0.7;
      letter-spacing: 0.08em;
    }

    .value {
      font-size: 13px;
    }

    .row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
    }

    .countdown {
      font-size: 18px;
      font-weight: 600;
    }

    .next-time {
      font-size: 12px;
      opacity: 0.8;
    }

    .actions {
      margin-top: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
      background: #1d4ed8;
      color: #f9fafb;
      font-weight: 500;
      transition: background 0.15s ease, transform 0.05s ease;
    }

    button:hover {
      background: #2563eb;
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
    }

    .small {
      font-size: 11px;
      opacity: 0.75;
    }

    .error {
      color: #fca5a5;
      font-size: 12px;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div class="page">
    <h1>Boss Respawn Timers</h1>
    <div class="subtitle">
      Data source: Google Sheet &nbsp;•&nbsp; Times based on your browser's timezone
    </div>

    <div id="error" class="error" style="display:none;"></div>
    <div id="boss-list" class="boss-grid"></div>
  </div>

  <script>
    // 1) Set this to your Apps Script Web App URL
    const API_URL = 'https://script.google.com/macros/s/AKfycbyMxe_s06Cwp4ZqJmDKFEjU5bjLlNZ2xC55I2BK7OZKAGRaQiWbCxqG73FyLaDxoIr6/exec';

    // If you enabled a TOKEN in Apps Script, put it here and it will be sent with POST
    const API_TOKEN = null; // e.g. 'my-super-secret-token';

    // Keep current bosses and intervals
    let bossesData = [];
    let countdownIntervalId = null;

    const WEEKDAY_INDEX = {
      Sunday: 0,
      Monday: 1,
      Tuesday: 2,
      Wednesday: 3,
      Thursday: 4,
      Friday: 5,
      Saturday: 6,
    };

    function formatCountdown(ms) {
      if (ms <= 0) return '00:00:00';

      const totalSeconds = Math.floor(ms / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;

      const pad = (n) => String(n).padStart(2, '0');
      return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
    }

    function formatDateTime(dt) {
      if (!dt) return 'Unknown';
      return dt.toLocaleString(undefined, {
        year: 'numeric',
        month: 'short',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
      });
    }

    function nextWeeklyOccurrence(dayName, time24, fromDate) {
      if (!dayName || !time24 || !WEEKDAY_INDEX.hasOwnProperty(dayName)) {
        return null;
      }

      const [hourStr, minuteStr] = time24.split(':');
      const hour = parseInt(hourStr, 10);
      const minute = parseInt(minuteStr, 10);

      const targetDow = WEEKDAY_INDEX[dayName];
      const curDow = fromDate.getDay();

      let deltaDays = (targetDow - curDow + 7) % 7;

      const candidate = new Date(fromDate.getTime());
      candidate.setSeconds(0, 0);
      candidate.setDate(candidate.getDate() + deltaDays);
      candidate.setHours(hour, minute, 0, 0);

      if (candidate <= fromDate) {
        candidate.setDate(candidate.getDate() + 7);
      }

      return candidate;
    }

    function computeNextRespawn(boss) {
      const now = new Date();

      if (boss.respawn_type === 'dynamic') {
        if (!boss.last_death_iso || !boss.respawn_hours) return null;
        const death = new Date(boss.last_death_iso);
        if (isNaN(death.getTime())) return null;

        const hrs = Number(boss.respawn_hours);
        if (!hrs || isNaN(hrs)) return null;

        return new Date(death.getTime() + hrs * 60 * 60 * 1000);
      }

      if (boss.respawn_type === 'fixed') {
        const candidates = [];

        if (boss.fixed_day_1 && boss.fixed_time_1_24h) {
          const c1 = nextWeeklyOccurrence(boss.fixed_day_1, boss.fixed_time_1_24h, now);
          if (c1) candidates.push(c1);
        }

        if (boss.fixed_day_2 && boss.fixed_time_2_24h) {
          const c2 = nextWeeklyOccurrence(boss.fixed_day_2, boss.fixed_time_2_24h, now);
          if (c2) candidates.push(c2);
        }

        if (!candidates.length) return null;

        // choose earliest
        return candidates.reduce((earliest, cur) => (cur < earliest ? cur : earliest));
      }

      return null;
    }

    function slugify(name) {
      return name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    }

    function renderBosses(bosses) {
      const container = document.getElementById('boss-list');
      container.innerHTML = '';

      bosses.forEach((boss) => {
        const slug = slugify(String(boss.boss_name || 'boss'));

        const card = document.createElement('div');
        card.className = 'boss-card';
        card.dataset.bossName = boss.boss_name;

        card.innerHTML = `
          <div class="boss-header">
            <div class="boss-name">${boss.boss_name || 'Unknown'}</div>
            <div class="boss-type ${boss.respawn_type === 'fixed' ? 'fixed' : 'dynamic'}">
              ${boss.respawn_type || 'unknown'}
            </div>
          </div>
          <div class="row">
            <div>
              <div class="label">Last Death</div>
              <div class="value" id="last-death-${slug}">${boss.last_death_iso ? formatDateTime(new Date(boss.last_death_iso)) : '—'}</div>
            </div>
            <div>
              <div class="label">Respawn</div>
              <div class="value">
                ${
                  boss.respawn_type === 'dynamic'
                    ? (boss.respawn_hours ? boss.respawn_hours + 'h' : '—')
                    : `${boss.fixed_day_1 || ''} ${boss.fixed_time_1_24h || ''}${
                        boss.fixed_day_2 ? ', ' + boss.fixed_day_2 + ' ' + (boss.fixed_time_2_24h || '') : ''
                      }`
                }
              </div>
            </div>
          </div>
          <div class="row">
            <div>
              <div class="label">Next Respawn</div>
              <div class="next-time" id="next-time-${slug}">Calculating…</div>
            </div>
            <div class="countdown" id="countdown-${slug}">--:--:--</div>
          </div>
          <div class="actions">
            <button data-action="death-now" data-boss="${boss.boss_name}">Death Now</button>
            <div class="small">${boss.notes ? boss.notes : ''}</div>
          </div>
        `;

        container.appendChild(card);
      });

      // Attach button handlers
      container.querySelectorAll('button[data-action="death-now"]').forEach((btn) => {
        btn.addEventListener('click', async (e) => {
          const bossName = e.currentTarget.getAttribute('data-boss');
          await markDeathNow(bossName);
        });
      });
    }

    function startCountdowns() {
      if (countdownIntervalId) {
        clearInterval(countdownIntervalId);
      }

      countdownIntervalId = setInterval(() => {
        bossesData.forEach((boss) => {
          const slug = slugify(String(boss.boss_name || 'boss'));
          const countdownEl = document.getElementById(`countdown-${slug}`);
          const nextTimeEl = document.getElementById(`next-time-${slug}`);

          const nextRespawn = computeNextRespawn(boss);
          if (!nextRespawn) {
            if (countdownEl) countdownEl.textContent = '--:--:--';
            if (nextTimeEl) nextTimeEl.textContent = 'Unknown';
            return;
          }

          const now = new Date();
          const msRemaining = nextRespawn - now;

          if (countdownEl) {
            countdownEl.textContent = formatCountdown(msRemaining);
          }

          if (nextTimeEl) {
            nextTimeEl.textContent = formatDateTime(nextRespawn);
          }
        });
      }, 1000);
    }

    async function fetchBosses() {
      const errorEl = document.getElementById('error');
      errorEl.style.display = 'none';

      try {
        const res = await fetch(API_URL);
        const data = await res.json();

        if (!data.ok) {
          throw new Error(data.error || 'Unknown error');
        }

        bossesData = data.bosses || [];
        renderBosses(bossesData);
        startCountdowns();
      } catch (err) {
        errorEl.textContent = 'Failed to load bosses: ' + err.message;
        errorEl.style.display = 'block';
      }
    }

    async function markDeathNow(bossName) {
      if (!bossName) return;

      const errorEl = document.getElementById('error');
      errorEl.style.display = 'none';

      try {
        const now = new Date().toISOString(); // browser timezone -> ISO; Apps Script will store as plain text

        const bodyObj = {
          boss_name: bossName,
          last_death_iso: now,
        };

        if (API_TOKEN) {
          bodyObj.token = API_TOKEN;
        }

        // IMPORTANT: do NOT set Content-Type: application/json to avoid CORS preflight.
        const res = await fetch(API_URL, {
          method: 'POST',
          body: JSON.stringify(bodyObj),
        });

        const data = await res.json();

        if (!data.ok) {
          throw new Error(data.error || 'Unknown error');
        }

        // Reload bosses after successful update
        await fetchBosses();
      } catch (err) {
        errorEl.textContent = 'Failed to update boss death: ' + err.message;
        errorEl.style.display = 'block';
      }
    }

    // Init
    document.addEventListener('DOMContentLoaded', () => {
      fetchBosses();
    });
  </script>
</body>
</html>
